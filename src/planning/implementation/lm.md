# Linear Memory & GC Runtime
## Regions
Note that for some of this we might be able to define [custom sections](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections).

### Roots/Reference Stack
- Pointers cannot be on WASM stack because we need to be able to mark and update them
- Will need associated mutable global `$ref_sp`
- Size: Probably fixed 1-3 mb, modifyable via compiler flag
#### Addendum 2022.3.17
- Upon further [review](../brainstorm/ref_stack_vars.md) it was determined that a second stack is required for storing locals with the original stack being devoted for roots associated with temporary operations
- Both stacks contain roots and thus all pointers should be marked

### User Static Data
- Used for storing things like string literals and `static_region` + `static_init_byte`
- Size: known at compile time but determined by what the program does

### Nursery
- This is where the shortest lived objects are stored. Doing a generational Garbage collector
- Associated mutable globals for optimizations
- Size: Probably fixed 512 kb

### Heap
- Longer term objects stored as described below
- Size: variable at runtime

## Heap Object Headers
Stores metadata for the relevant object pointer. Below examples are in C/C++ only for readability, planning on writing it directly in WASM.
```cpp
struct gc_heap_object_t {
    // This tells us where within the object there are references
    // - Each bit represents a 32 bit block
    // - pointer to bitfield stored in static memory, generated by compiler
    // - if nullptr then it contains no references
    // - length = this->size / 4
    void* refs_bitfield_addr;  // uint32_ptr_t

    // Referenced by other nodes?
    // Used during mark phase
    bool mark : 2;

    // How much storage do we have allocated (multiples of 32 bits)
    unsigned size : 30

    // Next pointer so that we can iterate over and free pointers
    // TODO this is not needed in the nursery, remove it (optimization)
    // Currently used to cache move address in nursery
    struct gc_heap_object_t* next; // uint32_ptr_t
};
```

## Free space LL
Nodes in the linked list are stored at the start of free space regions, so the address of the node is the start
```cpp
struct gc_heap_empty_t {
    // Note that this is a header for unused regions
    // thus implied: void* start_addr = this;

    // How much free space do we have here
    // - multiples of 32 bits
    // - could be smaller
    // - note includes space occupied by this
    uint32_t size;

    // Next available free space
    struct gc_heap_empty_t* next; // uint32_ptr_t
};

// Root element of LL
struct gc_heap_empty_t* gc_free_start;
```

New free spaces are inserted at the start of the ll such that the last one is always at the end of LM... ideally we'd have them in some order

We have to keep the sizes of heap allocations aligned to 64 bits

```C++
void coalesce_heap() {
    sort_freelist_by_address();
    for (auto* p = start; p->next; p = p->next)
        if (p + p->size === p->next) {
            p->size += p->next->size;
            p->next = p->next->next;
        }
}
```

## GC behavior
### Use
- On the value stack, reference/root stack indicies are passed around
- To get an address the index is dereferenced
- To get values, an address is dereferenced

### Minor - Mark
- Go through the values in the root/ref stack
- if the item is in the nursery, recursively mark it's references (which are also in the nursery)

### Minor - Sweep
After sweep, go through nursery, any values marked get copied into the main heap (TODO elaborate on this lol)

#### Major - Mark
- Values in the root/ref stack get marked
- Recursively follow pointers from the references bitmask and mark the

#### Major Sweep
- Starting at the first gc heap object
- Iterate through the LL, deleting unmarked objects

## Room for Improvement
- Segregation based on the size of the values being stored
- Probably a lot of room for optimization and avoiding linked list walks

## API
Rough ideas for the implmentation
### User-facing
- `fun $__gc_alloc (param i32 $size, i32 $bitmask_adddr) (result i32 $address)`:
    - allocates an object on the heap, returns pointer to the object
    - afterwards need to initialize the memory in this location
    - if nursery is too full to allocate, do a minor gc
    - if this is our 10th (arbirtrary) minor GC, do a major gc

### Internal Internal use only
- `$do_minor_gc`, `$do_major_gc`, `mark_minor`, `sweep_minor`, `mark_major`, `sweep_major`, ...
- `$coalesce`: goes through the free-space linked list and connects adjacent free spaces

### Mutable Globals
- `$ref_sp`: head of the reference stack
- `$gc_object_ll_head`: first gc'd object