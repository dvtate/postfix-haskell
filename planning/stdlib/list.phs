"./prelude.phs" require $prelude =

# Macro to construct a type for Linked Lists containing elements of given type
(:  $ElemType =

    # Using namespace prelude within this macro
    prelude use

    # Linked List with members of given type
    ( $ListType rec:
        ( ) type class $Nil =
        ( ElemType ListType ) class $Node =
    ) enum $ListType =

    # Member type of the list
    ElemType $ListType.ElemType =

    # Shortcut for empty list
    () ListType.Nil make $ListType.empty =

    # Append item to list head
    ((ElemType ListType):
        ( $m $l ) =
        ( m l ) ListType.Node make
    ) $cons =

    # Length of linked list
    (:  (rec:
            $ret =
            (   ListType.Nil (:
                    pop
                    ret
                )
                ListType.Node (:
                    unpack ( $v $next ) =
                    next  ret 1 + iter
                )
            ) match
        ) $iter =
        0 iter
    ) $ListType.length =

    # Get item at specific index in list
    "
    ((ListType I32):
        (rec: ( $ll $i ) =
            (
                ListType.Nil (:

                )

            ) match
            (: )
        ) $iter =
        iter
    ) $ListType.at =
    " pop


    # Apply function to each element of the list
    (( ListType  Syntax:Macro (ElemType) (Any) Arrow | ) rec:
        $f =
        (   ListType.Nil (: ListType.Nil make )
            ListType.Node (:
                unpack ( $v $n ) =
                (   v f
                    n $f ~ ListType.map
                ) ListType.Node make
            )
        ) match
    ) $ListType.map =

    # Reduce list into single value starting from the left
    # <list> <initial val> <accumulator> foldl
    (( ListType  Any  Syntax:Macro (Any ElemType) (Any) Arrow | ) rec:
        ( $z $f ) =
        (   ListType.Node (:
                unpack ( $x $xs ) =
                xs
                z x f
                $f ~
                ListType.foldl
            )
            ListType.Nil (: z )
        ) match
    ) $ListType.foldl =

    # Like foldl but goes the other way around (note: not tail recursive)
    (( ListType  Any  Syntax:Macro (ElemType Any) (Any) Arrow | ) rec:
        ( $z $f ) =
        (   ListType.Node (:
                unpack ( $x $xs ) =
                x
                xs z $f ~ ListType.foldr
                    f
            )
            ListType.Nil (: z )
        ) match
    ) $ListType.foldr =

    # Reverse the list
    (( ListType ):
        (rec: $ret =
            (   ListType.Nil (: pop ret )
                ListType.Node (:
                    unpack ( $x $xs ) =
                    xs
                    ( x ret ) ListType.Node make
                    iter
                )
            ) match
        ) $iter =
        () ListType.Nil make
    ) $ListType.reverse =

    # TODO foldr take drop concat ++ find elem filter some


    # Return the List type we created
    ListType
) $List =

# Honestly not sure if these should be in prelude ns anymore
(( Any List Syntax:Macro (Any) (Any) Arrow | ):
    ( $l $f ) =
    l type $LT =
    f type (LT.ElemType) (Any) Arrow Syntax:Macro | ==
)
(: ( $l $f ) = l type $ListType = l $f ~ ListType.map )
$prelude.map fun