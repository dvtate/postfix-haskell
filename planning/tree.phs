"../std/lang.phs" require use
"../std/maybe.phs" require $maybe =
"../std/list.phs" require $List =
"../std/io.phs" require $io =

((Syntax:Type Syntax:Type):
    ( $KeyType $ElemType ) =

    ( $Tree rec:
        () type class $Nil =
        ( KeyType ElemType Tree Tree ) class $Node =
    ) enum $Tree =

    ((Tree KeyType ElemType) rec: # set tree key value
        ( $t $key $value ) =

        t (
            # Make new [sub]tree
            Tree.Nil (:
                pop
                (
                    key
                    value
                    () Tree.Nil make
                    () Tree.Nil make
                ) Tree.Node make
            )

            # Search Existing tree
            Tree.Node (:
                unpack ( $k $v $l $r ) =

                # Same key -> update node with new value
                (: 
                    # k key == 
                    1
                ) (()(Tree):
                    ( k value l r ) Tree.Node make
                ) $branch fun

                # GT: branch right
                (: k key > ) (()(Tree):
                    # Recurse into right branch
                    r key value Tree.set $new_r =
                    ( k v l new_r ) Tree.Node make
                ) $branch fun

                # LT: branch left
                (: k key < ) (()(Tree):
                    # Recurse into left branch
                    l key value Tree.set $new_l =
                    ( k v new_l r ) Tree.Node make
                ) $branch fun
                branch
            )
        ) match
    ) $Tree.set =

    ((Tree KeyType) rec:
        ( $t $key ) =

        ElemType maybe.Maybe $Maybe =

        t (
            # Not in empty tree
            Tree.Nil (:
                pop
                () Maybe.Nothing make
            )

            Tree.Node (:
                unpack ( $k $v $l $r ) =

                # Same key: We found it!
                (: 
                    # k key == 
                    true
                ) (:
                    v Maybe.Just make
                ) $branch fun

                # GT: branch right
                (: k key > ) (:
                    r key Tree.get
                ) $branch fun

                # LT: branch left
                (: k key < ) (:
                    l key Tree.get
                ) $branch fun
                branch
            )
        ) match
    ) $Tree.get =

    # This isn't the right way to do it
    ((Tree):

        ( KeyType ElemType ) List.List $ListType =

        (rec:
            ( $tree $ret ) =
            
            tree (
                Tree.Nil (:
                    pop
                    ret
                )
                Tree.Node (:
                    unpack ( $k $v $l $r ) =

                    r ( ( k v ) ret ) ListType.Node make
                    iter

                    l swap iter
                )
            ) match
        ) $iter =

        () ListType.Nil make
        iter
    ) $Tree.entries =

    # get_row - Get the keys for tree nodes at specified depth from the root
    ((Tree I32):
        ( $tree $depth ) =

        KeyType List.List $LT =

        ((LT Tree I32) (LT) rec: # ret tree i
            $i =
            (   Tree.Nil (: pop $ret = ret )           # dead end, return list
                Tree.Node (:
                    unpack ( $k $v $l $r ) =
                    # PROBLEM: dep expr only unpacked in first case of branch, not both
                    # WORKAROUND: force evaluation before branch body but this is ugly
                    k (I32) (I32) Arrow "(;fuck;)" __asm
                    #( k ) seq # workaroud for a bug
                    (: 1 ) (:               # i <= 0
                        LT.cons           # append key to start of return list
                    ) $branch fun
                    (: i 0 > ) (:       # recursive case
                        pop
                        r i 1 - dfs     # append right side to start of list
                        l i 1 - dfs     # append left side to start of list
                    ) $branch fun
                    branch   
                )
            ) match
        ) $dfs =

        () LT.Nil make tree depth dfs
    ) $Tree.get_row =


    $Tree ~
) $BSTreeMap =


I32 F64 BSTreeMap $Tree =


#() Tree.Nil make
#2 2.0 Tree.set
#0 0.0 Tree.set
#1 1.0 Tree.set
#3 3.0 Tree.set
#4 4.0 Tree.set
#5 5.0 Tree.set
#
#dup -1 Tree.get :data
#dup 0 Tree.get :data
#dup 1 Tree.get :data
#dup 2 Tree.get :data
#dup 3 Tree.get :data
#dup 4 Tree.get :data
#dup 5 Tree.get :data
#dup 6 Tree.get :data
#pop


# Import Math.random from javascript
Unit (F64) Arrow ( "js" "Math.random" ) import $random =

# Add n elements to a tree
(( Unit Tree I32 ) (Unit Tree) rec:
    ( $t $n ) =
    (: 1 ) (: $u = u t ) $b fun
    (: n 0 > ) (:
        t random 100 * I32 cast n F64 cast Tree.set
        n 1 -
        mk_tree
    ) $b fun
    b
) $mk_tree =

(:
    ( $u $t ) =
    t Tree.entries $l =
    l type $ListType =

    # <list> <initial val> <accumulator> foldl
    #(( ListType  Any  Syntax:Macro (Any ElemType) (Any) Arrow | ):

    l u (:
        unpack ( $k $v ) =
        k io.print
    ) ListType.foldr
) $print_tree_keys =

(:
    $tree =
    tree type $TT =
    (rec:
        ( $u $t $i ) =
        u

        t i TT.get_row $r =

        r type $LT =

        (: 1 ) (:
            r swap (: io.print ) LT.foldr
            "---" io.print
            t i 1 + for_each_row
        ) $branch fun
        (: r LT.is_empty ) (: $u = $u ~ ) $branch fun
        branch
    ) $for_each_row =

    tree 0 for_each_row

) $print_tree =

( Unit io.IO I32 ) (:

    $n =

    () Tree.Nil make
    n mk_tree
    $t =
    t print_tree

    #t (
    #    Tree.Nil (: pop -1 )
    #    Tree.Node (:
    #        unpack ( $k $v $l $r ) =
    #        l (
    #            Tree.Nil (: pop -2 )
    #            Tree.Node (: 
    #                unpack ( $k2 $v2 $l2 $r2 ) =
    #                k2
    #            )
    #        ) match
    #    )
    #) match

    #t n Tree.get dup type $MT =
    #-1.0 MT.or_default
    #t n2 Tree.get
    #-1.0 MT.or_default +
) "demo" export
