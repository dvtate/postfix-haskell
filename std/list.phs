"./lang.phs" require $lang =
"./maybe.phs" require $maybe =

# Macro to construct a type for Linked Lists containing elements of given type
(:  $ElemType =

    # Using namespace lang within this macro
    lang use

    # Linked List with members of given type
    ( $ListType rec:
        ( ) type class $Nil =
        ( ElemType ListType ) class $Node =
    ) enum $ListType =

    # Member type of the list
    ElemType $ListType.ElemType =

    # Shortcut for empty list
    () ListType.Nil make $ListType.empty =

    # Append item to list head
    (( ListType ElemType ):
        ( $l $m ) =
        ( m l ) ListType.Node make
    ) $ListType.cons =

    # Length of linked list
    (:  (rec:
            $ret =
            (   ListType.Nil (:
                    pop
                    ret
                )
                ListType.Node (:
                    unpack ( $v $next ) =
                    next  ret 1 + iter
                )
            ) match
        ) $iter =
        0 iter
    ) $ListType.length =

    # Get item at specific index in list, returns maybe
    ((ListType I32):
        $index =
        ElemType maybe.Maybe $MT =
        ((ListType I32) (MT) rec:
            $i =
            (   ListType.Nil (:
                    pop () MT.Nothing make
                )
                ListType.Node (:
                    unpack ( $v $tail ) =
                    (: 1 ) (: tail i 1 + iter ) $b fun
                    (: i index == ) (: v MT.Just make ) $b fun
                    b
                )
            ) match
        ) $iter =
        0 iter
    ) $ListType.at_maybe =

    # Get item at specific index in list, trap if OOB
    ((ListType I32) rec:
        $index =
        (   ListType.Nil (:
                # OOB! trap
                pop Unit ( ElemType ) Arrow "(unreachable)" __asm
            )
            ListType.Node (:
                unpack ( $v $tail ) =
                (: 1 ) (: tail index 1 - ListType.at ) $b fun
                (: index 0 == ) (: v ) $b fun
                b
            )
        ) match
    ) $ListType.at =

    # Apply function to each element of the list
    (( ListType  Syntax:Macro (ElemType) (Any) Arrow | ):
        $f =
        (rec:
            (   ListType.Nil (: ListType.Nil make )
                ListType.Node (:
                    unpack ( $v $n ) =
                    (   v f
                        n iter
                    ) ListType.Node make
                )
            ) match
        ) $iter =
        iter
    ) $ListType.map =

    # Reduce list into single value starting from the left
    # <list> <initial val> <accumulator> foldl
    (( ListType  Any  Syntax:Macro (Any ElemType) (Any) Arrow | ):
        $f =
        (rec:
            $z =
            (   ListType.Node (:
                    unpack ( $x $xs ) =
                    xs
                    z x f
                    iter
                )
                ListType.Nil (: pop z )
            ) match
        ) $iter =
        iter
    ) $ListType.foldl =

    # Like foldl but goes the other way around (note: not tail recursive)
    (( ListType  Any  Syntax:Macro (Any ElemType) (Any) Arrow | ):
        $f =
        (rec:
            $z =
            (   ListType.Node (:
                    unpack ( $x $xs ) =
                    xs z iter
                    x
                        f
                )
                ListType.Nil (: pop z )
            ) match
        ) $iter =
        iter
    ) $ListType.foldr =

    # Reverse the list
    (( ListType ):
        (rec: $ret =
            (   ListType.Nil (: pop ret )
                ListType.Node (:
                    unpack ( $x $xs ) =
                    xs
                    ( x ret ) ListType.Node make
                    iter
                )
            ) match
        ) $iter =
        () ListType.Nil make
        iter
    ) $ListType.reverse =

    (( ListType Syntax:Macro (ElemType) (I32) Arrow | ):
        $cond =
        (rec:
            $ret =
            (   ListType.Node (:
                    unpack ( $x $xs ) =
                    # Skip element if cond fails
                    (: 1 ) (: xs ret iter ) $branch fun
                    (: x cond ) (: ( x xs ret iter ) ListType.Node make )
                )
                ListType.Nil (: pop ret )
            ) match
        ) $iter =
        iter
    ) $ListType.filter =

    (rec:
        ( $a $b ) =
        a (
            ListType.Nil (:
                b (
                    ListType.Nil (: 
                        pop true
                    )
                    ListType.Node (:
                        pop false
                    )
                ) match
            )
            ListType.Node (:
                unpack ( $a_v $a_tail ) =
                b (
                    ListType.Nil (:
                        pop false
                    )
                    ListType.Node (:
                        unpack ( $b_v $b_tail ) =
                        (: 1 ) (:
                            false
                        ) $branch fun
                        (: a_v b_v == ) (:
                            a_tail b_tail ListType.equals
                        ) $branch fun
                        branch
                    )
                ) match
            )
        ) match
    ) $ListType.equals =

    ((ListType):
        (   ListType.Nil (: pop true )
            ListType.Node (: pop false )
        ) match
    ) $ListType.is_empty =

    ((ListType ListType):
        (: ListType.cons ) ListType.foldr
    ) $ListType.concat =

    (( ListType I32 ):
        ((ListType I32) (ListType) rec:
            ( $n $i ) =

            (: 1 ) (: ListType.empty ) $branch fun
            (: i 0 > ) (:
                n (
                    ListType.Nil (:
                        pop
                        ListType.empty
                    )
                    ListType.Node (:
                        unpack ( $v $tail ) =
                        tail
                        i 1 -
                        iter
                        v ListType.cons
                    )
                ) match
            ) $branch fun
            branch
        ) $iter =
        iter
    ) $ListType.take =

    # TODO FIXME why does adding type signature here make tree.phs compilation fail?
    (: #( ListType I32 ):
        $num =
        (:  (   ListType.Nil (: ListType.Nil make )
                ListType.Node (:
                    unpack ( $___ $tail ) =
                    tail
                )
            ) match
        ) num lang.loop
    ) $ListType.drop =

    # TODO elem find some

    # Return the List type we created
    ListType
) $List =

# Why doesn't this work??
#(( Any List dup :stack ):
#    ( $a $b ) =
#    a type b type ==
#) (:
#    a type $LT =
#    a b LT.equals
#) $global.== fun


# Honestly not sure if these should be in lang ns anymore
#(( Any List Syntax:Macro (Any) (Any) Arrow | ):
#    ( $l $f ) =
#    l type $LT =
#    f type (LT.ElemType) (Any) Arrow Syntax:Macro | ==
#)
#(: ( $l $f ) = l type $ListType = l $f ~ ListType.map )
#$lang.map fun